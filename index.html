<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-s


    <script>
        'use strict';
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const openingScreenUI = document.getElementById('openingScreen');
        const scoreUI = document.getElementById('score');
        const gameOverScreenUI = document.getElementById('gameOverScreen');
        const finalScoreUI = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        const enemyImages = {
            takase: new Image(),
            shimizu: new Image()
        };
        enemyImages.takase.src = 'takase02.png';
        enemyImages.shimizu.src = 'shimizu.png';

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioInitialized = false;

        const bgm = new Audio('https://otologic.jp/sounds/bgm/mp3/Simple_Pop_3.mp3');
        bgm.loop = true;
        const shootSound = new Audio('https://otologic.jp/sounds/se/mp3/se-pop12.mp3');
        const hitSound = new Audio('https://otologic.jp/sounds/se/mp3/se-pop02.mp3');

        const GameState = { OPENING: 'OPENING', PLAYING: 'PLAYING', GAME_OVER: 'GAME_OVER' };
        let currentState = GameState.OPENING;
        let player, bullets, enemies, particles, score, bulletTimer, enemyTimer, mouse;
        let imagesLoaded = false;
        let imagesToLoad = 2;

        function checkImagesLoaded() {
            imagesToLoad--;
            if (imagesToLoad === 0) {
                imagesLoaded = true;
            }
        }

        enemyImages.takase.onload = checkImagesLoaded;
        enemyImages.shimizu.onload = checkImagesLoaded;
        enemyImages.takase.onerror = () => { console.error('takase02.pngの読み込みに失敗しました。'); checkImagesLoaded(); };
        enemyImages.shimizu.onerror = () => { console.error('shimizu.pngの読み込みに失敗しました。'); checkImagesLoaded(); };

        function initialize() {
            player = { x: canvas.width / 2, y: canvas.height - 40, size: 30, color: '#FFFACD' };
            bullets = [];
            enemies = [];
            particles = [];
            score = 0;
            bulletTimer = 0;
            enemyTimer = 0;
            mouse = { x: null, y: null, radius: 100 };
            
            let numberOfParticles = (canvas.width * canvas.height) / 9000;
            for (let i = 0; i < numberOfParticles; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    directionY: Math.random() * -1 - 0.5
                });
            }
        }

        function setupEventListeners() {
            openingScreenUI.addEventListener('mousedown', handleStart);
            openingScreenUI.addEventListener('touchstart', handleStart);
            restartButton.addEventListener('click', handleRestart);
            canvas.addEventListener('mousemove', moveHandler);
            canvas.addEventListener('touchmove', moveHandler);
        }

        function handleStart(e) {
            e.preventDefault();
            if (currentState !== GameState.OPENING || !imagesLoaded) return;
            // オーディオの初期化をユーザーの最初の操作時に行う
            if (!audioInitialized) {
                audioContext.resume().then(() => {
                    audioInitialized = true;
                    bgm.play();
                }).catch(error => {
                    console.error('オーディオの再生が許可されませんでした:', error);
                });
            } else {
                bgm.play();
            }
            resetGame();
            changeState(GameState.PLAYING);
        }

        function handleRestart() {
            if (currentState !== GameState.GAME_OVER) return;
            resetGame();
            changeState(GameState.PLAYING);
        }

        function moveHandler(e) {
            e.preventDefault();
            const pos = e.touches ? e.touches[0] : e;
            mouse.x = pos.clientX;
            mouse.y = pos.clientY;
            if (currentState === GameState.PLAYING) {
                player.x = pos.clientX;
            }
        }
        
        function changeState(newState) {
            currentState = newState;
            openingScreenUI.style.display = (newState === GameState.OPENING) ? 'flex' : 'none';
            scoreUI.style.display = (newState === GameState.PLAYING) ? 'block' : 'none';
            gameOverScreenUI.style.display = (newState === GameState.GAME_OVER) ? 'block' : 'none';
            if (newState === GameState.PLAYING && audioInitialized) {
                bgm.play();
            } else {
                bgm.pause();
                bgm.currentTime = 0;
            }
        }

        function resetGame() {
            score = 0;
            player = { x: canvas.width / 2, y: canvas.height - 40, size: 30, color: '#FFFACD' }; 
            bullets = [];
            enemies = [];
            bulletTimer = 0;
            enemyTimer = 0;
            scoreUI.textContent = 'Score: 0';
        }

        function update() {
            if (currentState !== GameState.PLAYING) return;
            
            bulletTimer++;
            if (bulletTimer % 10 === 0) { 
                bullets.push({ x: player.x, y: player.y, size: 10, color: '#FF00FF', speed: 10 });
                playSound(shootSound);
            }

            enemyTimer++;
            if (enemyTimer % 60 === 0) {
                const size = 50;
                const speed = 1 + Math.random() * 2;
                const image = Math.random() > 0.5 ? enemyImages.takase : enemyImages.shimizu;
                enemies.push({ x: Math.random() * (canvas.width - size) + size / 2, y: -size, size: size, speed: speed, image: image });
            }
            
            bullets.forEach(b => b.y -= b.speed);
            enemies.forEach(e => e.y += e.speed);

            bullets = bullets.filter(b => b.y > -b.size);
            enemies = enemies.filter(e => e.y < canvas.height + e.size);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (isColliding(player, enemy, 1.2)) {
                    finalScoreUI.textContent = `Score: ${score}`;
                    changeState(GameState.GAME_OVER);
                    return;
                }
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (isColliding(bullets[j], enemy, 1.2)) {
                        enemies.splice(i, 1);
                        bullets.splice(j, 1);
                        score += 100;
                        scoreUI.textContent = `Score: ${score}`;
                        playSound(hitSound);
                        break;
                    }
                }
            }
        }

        function isColliding(obj1, obj2, scale = 1) {
            const dist = Math.hypot(obj1.x - obj2.x, obj1.y - obj2.y);
            return dist < (obj1.size / 2 + obj2.size / 2) * scale;
        }
        
        function playSound(sound) {
            if (!audioInitialized) return;
            sound.currentTime = 0;
            sound.play();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawParticles();
            if (currentState === GameState.PLAYING || currentState === GameState.GAME_OVER) {
                drawPlayer();
                drawBullets();
                drawEnemies();
            }
        }

        function drawParticles() {
            ctx.fillStyle = '#0c0c1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                if (mouse.x !== null) {
                    const dist = Math.hypot(mouse.x - p.x, mouse.y - p.y);
                    if (dist < mouse.radius) {
                        p.x -= (mouse.x - p.x) / 20;
                        p.y -= (mouse.y - p.y) / 20;
                    }
                }
                p.y += p.directionY;
                if (p.y < 0) {
                    p.x = Math.random() * canvas.width;
                    p.y = canvas.height;
                }
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
            });
        }
        
        function drawPlayer() {
            const p = player;
            const r = p.size / 2;
            const ir = p.size / 4;
            let rot = Math.PI / 2 * 3;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y - r);
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(p.x + Math.cos(rot) * r, p.y + Math.sin(rot) * r);
                rot += Math.PI / 5;
                ctx.lineTo(p.x + Math.cos(rot) * ir, p.y + Math.sin(rot) * ir);
                rot += Math.PI / 5;
            }
            ctx.closePath();
            ctx.fillStyle = p.color;
            ctx.fill();
        }

        function drawBullets() {
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.shadowColor = b.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function drawEnemies() {
            enemies.forEach(e => {
                if (e.image && e.image.complete) {
                    ctx.drawImage(e.image, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
                } else {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
                }
            });
        }
        
        function gameLoop() {
            if (imagesLoaded) {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = () => {
            initialize();
            setupEventListeners();
        };
    </script>
</body>
</html>
